#!/usr/bin/env python3
"""
Validates the format of project-context.md generated by build-context-gatherer.

This hook runs automatically after build-context-gatherer completes.
It ensures the context has all required sections before allowing the workflow to continue.
"""

import sys
import os
import json
from pathlib import Path

def validate_context(feature_id):
    """Validate the project context file format."""
    
    context_file = Path(f"docs/ai/features/{feature_id}/project-context.md")
    
    # Check if file exists
    if not context_file.exists():
        return False, f"Context file not found: {context_file}"
    
    # Read the content
    try:
        content = context_file.read_text()
    except Exception as e:
        return False, f"Error reading context file: {e}"
    
    # Define required sections
    required_sections = {
        "## Tech Stack": "List the project's technologies, frameworks, languages, databases, etc.",
        "## Architecture": "Describe the architectural patterns, structure, and key modules.",
        "## Conventions": "List naming conventions, file structure patterns, and code style rules.",
        "## Key Files": "List important configuration files, entry points, and critical modules."
    }
    
    # Check for missing sections
    missing_sections = []
    for section, guidance in required_sections.items():
        if section not in content:
            missing_sections.append(f"{section}\n{guidance}\n")
    
    if missing_sections:
        # Auto-fix: append missing section templates
        with open(context_file, 'a') as f:
            f.write("\n\n# ⚠️ MISSING SECTIONS - PLEASE FILL IN:\n\n")
            f.write("\n".join(missing_sections))
        
        return False, f"Context missing required sections: {', '.join([s.split('##')[1].strip() for s in required_sections.keys() if required_sections[list(required_sections.keys())[list(required_sections.values()).index(guidance)]] in missing_sections])}\n\nI've added section templates to the file. Please re-run build-context-gatherer."
    
    # Check that sections have content (not just headers)
    empty_sections = []
    for section in required_sections.keys():
        # Find the section and check if there's content after it
        section_index = content.find(section)
        if section_index != -1:
            # Get content until next ## or end of file
            next_section = content.find("\n##", section_index + len(section))
            if next_section == -1:
                section_content = content[section_index + len(section):]
            else:
                section_content = content[section_index + len(section):next_section]
            
            # Check if there's meaningful content (more than just whitespace)
            if len(section_content.strip()) < 10:
                empty_sections.append(section.replace("## ", ""))
    
    if empty_sections:
        return False, f"Context sections are empty or too brief: {', '.join(empty_sections)}\n\nPlease provide meaningful content for each section."
    
    return True, "Context format validated successfully"


def main():
    """Main validation entry point."""
    
    # Try to find the feature ID from recent files
    features_dir = Path("docs/ai/features")
    if not features_dir.exists():
        print("❌ Error: docs/ai/features/ directory not found")
        sys.exit(1)
    
    # Get the most recently modified feature directory
    feature_dirs = [d for d in features_dir.iterdir() if d.is_dir()]
    if not feature_dirs:
        print("❌ Error: No feature directories found in docs/ai/features/")
        sys.exit(1)
    
    # Use the most recently modified directory
    feature_dir = max(feature_dirs, key=lambda d: d.stat().st_mtime)
    feature_id = feature_dir.name
    
    # Validate the context
    is_valid, message = validate_context(feature_id)
    
    if is_valid:
        print(f"✅ {message}")
        sys.exit(0)
    else:
        print(f"❌ {message}")
        sys.exit(1)


if __name__ == "__main__":
    main()