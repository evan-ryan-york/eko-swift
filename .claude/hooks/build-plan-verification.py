#!/usr/bin/env python3
"""
Validates the format of implementation-plan.md generated by build-planner.

This hook runs automatically after build-planner completes.
It ensures the plan has proper structure and test specifications before execution begins.
"""

import sys
import re
from pathlib import Path

def validate_plan(feature_id):
    """Validate the implementation plan file format."""
    
    plan_file = Path(f"docs/ai/features/{feature_id}/implementation-plan.md")
    
    # Check if file exists
    if not plan_file.exists():
        return False, f"Plan file not found: {plan_file}"
    
    # Read the content
    try:
        content = plan_file.read_text()
    except Exception as e:
        return False, f"Error reading plan file: {e}"
    
    # Check 1: Must have at least one phase
    phase_pattern = r"^##\s+Phase\s+\d+:"
    phases = re.findall(phase_pattern, content, re.MULTILINE)
    
    if not phases:
        return False, "Plan must have at least one phase (e.g., '## Phase 1: Foundation')"
    
    # Check 2: Each phase must have steps
    phase_sections = re.split(r"^##\s+Phase\s+\d+:", content, flags=re.MULTILINE)[1:]  # Skip content before first phase
    
    if not phase_sections:
        return False, "Could not parse phases properly"
    
    empty_phases = []
    for i, phase_content in enumerate(phase_sections, 1):
        # Look for step patterns: "- Step X.Y:" or "- [ ] Step X.Y:" or numbered "1. Step X.Y:"
        step_pattern = r"(-|\d+\.)\s+(\[ \])?\s*Step\s+\d+\.\d+:"
        steps = re.findall(step_pattern, phase_content)
        
        if not steps:
            empty_phases.append(f"Phase {i}")
    
    if empty_phases:
        return False, f"Phases missing steps: {', '.join(empty_phases)}\n\nEach phase must have at least one step in format: '- Step X.Y: Description'"
    
    # Check 3: Must have overview or summary section
    has_overview = bool(re.search(r"^#\s+(Overview|Summary|Plan Summary)", content, re.MULTILINE | re.IGNORECASE))
    
    if not has_overview:
        return False, "Plan must include an overview or summary section at the top"
    
    # Check 4: Total step count should be reasonable
    all_steps = re.findall(r"Step\s+\d+\.\d+:", content)
    step_count = len(all_steps)
    
    if step_count == 0:
        return False, "Plan must contain at least one step"
    
    if step_count > 50:
        return False, f"Plan has {step_count} steps, which may be too granular. Consider consolidating into larger steps."
    
    # Check 5: Verify step numbering is sequential within phases
    for i, phase_content in enumerate(phase_sections, 1):
        steps = re.findall(r"Step\s+(\d+)\.(\d+):", phase_content)
        if steps:
            phase_numbers = [int(p) for p, _ in steps]
            step_numbers = [int(s) for _, s in steps]
            
            # All steps in this phase should have the same phase number
            if not all(p == i for p in phase_numbers):
                return False, f"Phase {i} has steps with mismatched phase numbers. All steps should be {i}.X"
            
            # Step numbers should start at 1 and increment
            expected_steps = list(range(1, len(step_numbers) + 1))
            if step_numbers != expected_steps:
                return False, f"Phase {i} has non-sequential step numbers: {step_numbers}. Expected: {expected_steps}"
    
    # Check 6: Verify test specifications are present where appropriate
    steps_with_logic = 0
    steps_with_tests = 0
    steps_with_no_test_justification = 0
    
    for i, phase_content in enumerate(phase_sections, 1):
        # Extract each step line
        step_lines = re.findall(r"(-|\d+\.)\s+(\[ \])?\s*Step\s+\d+\.\d+:.*", phase_content)
        
        for step_line in step_lines:
            step_text = step_line[2] if len(step_line) > 2 else step_line[0]
            
            # Skip if it's obviously non-logic (documentation, styling, config)
            if any(keyword in step_text.lower() for keyword in ['readme', 'documentation', 'update docs', 'styling only', 'config', 'migration']):
                continue
            
            steps_with_logic += 1
            
            # Check if it has test specification
            has_test_spec = bool(re.search(r'\(tests?:', step_text, re.IGNORECASE))
            has_no_test_justification = bool(re.search(r'\(no tests? needed', step_text, re.IGNORECASE))
            
            if has_test_spec:
                steps_with_tests += 1
            elif has_no_test_justification:
                steps_with_no_test_justification += 1
    
    # Warning if too few test specifications (but don't fail - some plans might be legit)
    if steps_with_logic > 5:  # Only check if there are meaningful steps
        test_coverage = (steps_with_tests + steps_with_no_test_justification) / steps_with_logic
        if test_coverage < 0.5:
            return False, (
                f"Low test specification coverage: Only {steps_with_tests} steps have test specs out of {steps_with_logic} logic steps.\n"
                f"Most steps with business logic should either:\n"
                f"  - Include test specifications: (tests: path/file.test.ts - what to test)\n"
                f"  - Justify why no test needed: (no test needed - reason)\n"
                f"Example: 'Step 2.1: Create User model (tests: models/user.test.ts - test validation, required fields)'"
            )
    
    return True, f"Plan validated successfully: {len(phases)} phases, {step_count} total steps, {steps_with_tests} with test specs"


def main():
    """Main validation entry point."""
    
    # Try to find the feature ID from recent files
    features_dir = Path("docs/ai/features")
    if not features_dir.exists():
        print("❌ Error: docs/ai/features/ directory not found")
        sys.exit(1)
    
    # Get the most recently modified feature directory
    feature_dirs = [d for d in features_dir.iterdir() if d.is_dir()]
    if not feature_dirs:
        print("❌ Error: No feature directories found in docs/ai/features/")
        sys.exit(1)
    
    # Use the most recently modified directory
    feature_dir = max(feature_dirs, key=lambda d: d.stat().st_mtime)
    feature_id = feature_dir.name
    
    # Validate the plan
    is_valid, message = validate_plan(feature_id)
    
    if is_valid:
        print(f"✅ {message}")
        sys.exit(0)
    else:
        print(f"❌ {message}")
        sys.exit(1)


if __name__ == "__main__":
    main()